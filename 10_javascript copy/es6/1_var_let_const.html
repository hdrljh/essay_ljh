<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=\, initial-scale=1.0">
  <title>Document</title>
  <script>
    // ES6차(ES2015)

    // var, let, const의 차이

    // 1. var (*바는 몰라도 개발하는데 전혀 상관이 없다. 사용할 일이 거의 없다.)
    // 함수 스코프에 종속,  그 외엔 전역
    // 블록 기준으로 스코프가 생기지 않기 때문에 블록 밖에서 접근 가능
    // for문(블록 스코프) 내에서 var로 선언하면 for문 밖에서도 사용 가능
    for (let i = 0; i < 10; i++) {
      var leak = 'i am available outside of the loop'; //전역
    }
    console.log(leak);

    //-----------------------------------------------------------------//

    function myFunc() {
      var functionScoped = 'I am available inside this function';
      console.log(functionScoped);
    }
    myFunc();
    // console.log(functionScoped); // 함수를 벗어나면 접근 불가 에러가 뜬다.

    //-----------------------------------------------------------------//

    // 2. let
    // 블록 스코프에 종속, 그 외엔 전역
    // 블록스코프 = {} () [] 모든 괄호를 블록 스코프라 한다.
    // let 사용 예
    let x = 'global'; // X에 global 글자를 저장했다.
    if (x === 'global') {
      let x = 'block-scoped';
      console.log(x); // 위에 렛x (지역함수내)
    }
    console.log(x); //맨 상단 렛x (전역함수 x)

    // var 사용 예
    var y = 'global';
    if (y === 'global') {
      var y = 'block-scoped'
      console.log(y);
    }
    console.log(y); // y값이 변경되어 있음
    //위 var는 지역함수내 balck-scoped를 "중복선언" 한번씩 불러옴

    //-----------------------------------------------------------------//

    // 3. const
    // 블록 스코프에 종속, 그 외엔 전역
    // let와 차이점 : 값이 변결될 수 없다.
    const constant = 'I am a constant';
    // constant = 'reassigned'; // 값의 재할당 불가(위에 사용한 값을 재할당 할 수 없다.)

    // 만약에 const에 객체가 담겼다면???
    const person = {
      name: 'goni',
      age: 25
    };

    person.age = 26;
    console.log(person.age);
    // 변수 전체를 재할당하는 것이 아니라 그 속성 중 하나만 재할당하는 것이라 문제 없음
    // person 변수에는 객체의 주소값이 들어있음(참조 변수)
    // (참고) 객체의 내용을 변결할 수 있게 const 객체를 고정할 수는 있다.
    const fixPerson = {
      name: 'goni',
      age: 25
    };

    fixPerson.age = 26;
    console.log(fixPerson.age)

    Object.freeze(fixPerson); // 이것을 사용하면 객체를 고정할 수 있다(26 나이를 밑에 30으로 바꿔도 출력은 그대로 26이 된다.)

    fixPerson.age = 30;
    console.log(fixPerson.age)

    //-----------------------------------------------------------------//    

    // 4. 선언하기 전 사용할 수 있는 var
    console.log(iam);
    var iam = 'I am a varlable';
    // var는 정의되기 전에 접근 가능, 값은 비어있는 상태(undefined)

    // console.log(jam);
    let jam = 'I am a let';

    // let, const는 정의되기 전에 접근 불가!
    // 위에 바는 호이스팅이 일어나고 undefined값까지 일어남! 반대로 렛은 호이스팅이 안됨.

    //-----------------------------------------------------------------//

    //5. var는 중복 선언을 허용
    var user = 'Peter';
    var user = 'john';
    console.log(user);

    // var와 let, const의 차이점 정리
    // 1) 스코프가 다르다.
    // var로 선언한 변수는 블록 스코프가 아닌 함수 수준 스코프를 갖는다.
    // 2) var는 정의되기 전에 접근할 수 있다.(대신 값은 undefined)
    // 3) var는 중복 선언을 허용한다.





///////////////연습////////////////////////////

    // const jaehoon = {
    //   name: 'banana',
    //   age: '100',
    //   이름: '바나나',
    //   나이: '100'
    // }
    // console.log(jaehoon);
    // document.write(jaehoon);



  </script>
</head>

<body>

</body>

</html>